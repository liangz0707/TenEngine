# 多 Agent 协作：接口同步策略（T0 架构）

本文档说明在多个 Agent 协同开发 TenEngine **T0 架构（27 模块）** 时，如何**定义、引用和同步**跨模块接口，避免接口不一致导致的集成失败。

---

## 1. 原则

- **主分支仅用于配置**：**master**（或 main）分支仅用于仓库与工程配置（如构建、CI、文档索引等）；**契约内容不以主分支为来源**，各模块开发与接口同步不依赖主分支上的 `specs/_contracts/`。
- **契约必须从 T0-contracts 拉取**：契约的**唯一权威来源**是 **`T0-contracts`** 分支。所有 T0-* 模块分支的 Agent 必须且只能从 **`origin/T0-contracts`** 拉取契约（`git pull origin T0-contracts`），不得以主分支上的 `_contracts/` 作为契约依据。
- **单一事实来源**：跨模块的“谁提供什么、谁消费什么”写在 `specs/_contracts/` 的契约文件中（以 **T0-contracts** 分支为准）；各模块的规格引用契约而非重复描述接口细节。
- **契约先行**：下游模块（消费者）依赖的接口，由上游模块（提供方）的契约定义；Agent 在实现或改规格前先读契约（从 T0-contracts 拉取后的本地 `_contracts/`）。
- **变更即同步**：任何 Agent 修改某模块的**对外接口**时，必须更新对应契约文件（并合并到 `T0-contracts` 分支），并检查依赖该契约的模块列表，必要时在对应下游的 **`docs/module-specs/NNN-modulename.md`** 中增加待办（仅此一种策略，见 §4.4）。

---

## 2. T0 约束分支（T0-contracts）

- **分支名**：`T0-contracts`（建议远程：`origin/T0-contracts`）
- **用途**：专门维护 `specs/_contracts/` 下的契约文件、`docs/dependency-graph-full.md`（完整依赖图）及本文档；作为 **T0 架构下契约的单一发布源**。
- **各 T0-* 分支工作前**：在任意 T0-NNN-modulename 分支（如 `T0-001-core`、`T0-008-rhi`）上开始工作前，必须先从 `T0-contracts` 拉取最新契约，再基于最新契约实现或改规格。

```bash
# 在本地 T0-* 模块分支上拉取最新契约（二选一即可）
git fetch origin T0-contracts
git merge origin/T0-contracts

# 或
git pull origin T0-contracts
```

- **更新契约时**：在 `T0-contracts` 分支上修改契约文件，或通过 PR 将契约变更合并到 `T0-contracts`；其他分支通过上述拉取获得更新。

---

## 3. 目录与角色（T0 架构）

| 位置 | 用途 |
|------|------|
| **分支 master / main** | **仅用于配置**：仓库配置、构建、CI、文档索引等；**不**作为契约的来源，Agent 不得从主分支拉取契约。 |
| **分支 `T0-contracts`** | **契约的唯一权威来源**；契约与全局依赖图的官方维护分支；各 T0-* 分支**必须**从此分支拉取最新契约。 |
| **分支 `T0-NNN-modulename`** | 各模块的独立分支（如 T0-001-core … T0-027-xr），仅含约束 + 该模块描述 + 全局依赖；工作前须先 `git pull origin T0-contracts`。 |
| `specs/_contracts/`（以 T0-contracts 为准） | 存放**跨模块接口契约**：API 边界、数据类型、调用顺序、版本；**仅以 T0-contracts 分支上的内容为准**。 |
| `specs/_contracts/000-module-dependency-map.md` | T0 模块依赖图：27 模块谁依赖谁、契约一览。 |
| `docs/dependency-graph-full.md` | 完整依赖图（Mermaid、矩阵、边列表）；可在 T0-contracts 或各 T0-* 分支上查阅。 |
| `docs/module-specs/` | 各模块详细规格（001-core.md … 027-xr.md）；T0-contracts 或各 T0-NNN-* 分支可含对应内容。 |
| `.specify/memory/constitution.md` | 全局原则（如 ABI 版本、模块边界）；契约不得违反宪法。 |

每个 Agent 的工作范围通常对应一个 **T0-NNN-modulename** 分支；跨模块边界的接口**以从 T0-contracts 拉取后的契约为准**。

---

## 4. 工作流

### 4.1 开发/实现前

1. **拉取最新契约**：在当前 T0-* 分支上执行 `git fetch origin T0-contracts` 后 `git merge origin/T0-contracts`（或 `git pull origin T0-contracts`），确保本地的 `specs/_contracts/` 与约束分支一致。
2. 打开本模块对应的 `docs/module-specs/NNN-modulename.md`，查看 **Dependencies** 与上下游。
3. 阅读 `specs/_contracts/000-module-dependency-map.md`，确认本模块的上游（依赖谁）和下游（被谁依赖）。
4. 对每一个**上游依赖**，阅读其契约文件（如 `specs/_contracts/001-core-public-api.md`），在实现时只使用契约中已声明的类型与接口。

### 4.2 修改本模块对外接口时

1. 在 **`T0-contracts` 分支**上更新本模块对应的契约文件（见 `_contracts/` 下以模块或边界命名的文件），或通过 PR 将契约变更合并到 `T0-contracts`。
2. 在契约中注明**版本或变更说明**（与 Constitution 的版本/ABI 要求一致）。
3. **（必须）** 在 `000-module-dependency-map.md` 中查看**依赖本模块**的下游列表；若本次契约变更可能影响下游（如签名变更、删除、行为变更），则对每个下游**仅在其规约中增加待办**：
   - 在对应下游的 **`docs/module-specs/NNN-modulename.md`** 中增加一条待办，如：`- **待办**：需随 \`001-core\` 契约变更做适配（契约变更日期：YYYY-MM-DD；变更摘要：…）。`
   - 不直接修改下游的 feature 分支（checklist、tasks.md 等），以便多分支下通过规约同步即可；**具体适配时间与修改内容由下游根据待办与契约变更记录自行判断**。
   - **写回契约的流程中已包含本步**，见 `docs/workflow-two-modules-pilot.md` §4.2.5 步骤 5 与 `docs/workflow-pilot-ai-complete-guide.md` 步骤 1.4/2.5。

**若使用 Spec Kit /speckit.plan**：plan 产出的对外接口设计（函数签名、类型）**必须写回契约**。在 plan 完成后、tasks 之前，将 plan.md 或 plan 产出的「契约更新」清单同步到 `specs/_contracts/NNN-*-public-api.md` 的「API 雏形」小节，在 T0-contracts 上提交并推送；**然后执行上述步骤 3（在下游规约中增加待办）**；再在 worktree 拉取 T0-contracts 后继续 tasks/implement。详见 `docs/workflow-two-modules-pilot.md` §4.2.5。

### 4.3 评审/合并前

1. 检查：本 PR 是否改动某模块的**公开 API 或跨模块数据结构**？
2. 若有，确认 `specs/_contracts/` 下对应契约已更新，且依赖图与下游说明已更新或已创建跟进任务。

### 4.4 写回契约后通知下游：仅规约待办

写回契约后、若契约变更可能影响下游时，**统一只采用一种策略**：在对应下游的 **`docs/module-specs/NNN-modulename.md`** 中增加待办。

| 方式 | 位置 | 操作 |
|------|------|------|
| **规约待办（唯一策略）** | 下游模块规约 `docs/module-specs/NNN-modulename.md` | 增加一条待办，如：`- **待办**：需随 \`001-core\` 契约变更做适配（契约变更日期：YYYY-MM-DD；变更摘要：…）。` |

**原因**：多分支下不宜直接改下游的 feature 分支（如 `specs/<feature>/checklists/requirements.md`、`tasks.md`），否则需逐个 worktree/分支修改。仅改下游规约时，通过规约文件同步（如 T0-contracts 或主仓库拉取）即可让各下游 worktree 看到待办；**具体适配时间与修改内容由下游根据待办与契约变更记录自行判断**。

**下游如何修改 plan**：下游打开本模块规约看到待办后，根据**最新上游契约**检查并更新本模块的 **plan.md**（或重新执行 `/speckit.plan`），确保 plan 只使用契约中已声明的类型与 API。具体提示词与步骤见 **`docs/workflow-pilot-ai-complete-guide.md`** 中「上游契约已更新时，下游如何修改 plan」一节。

### 4.5 接口如何确定（伪代码 → API 雏形 → 真实 API）

当前契约主要描述**能力列表**与**类型/句柄**（如 IDevice、ICommandList、分配器、数学类型等），以及**调用顺序与约束**；多数尚未包含**具体函数签名**。本节明确**伪代码、API 雏形、真实 API** 三者的区别与演进流程。

#### 4.5.1 定义

| 层级 | 精确程度 | 示例 | 作用 |
|------|----------|------|------|
| **伪代码** | 低 | `Allocator.Alloc(size, alignment) → ptr or null` | 描述**意图与语义**，便于快速沟通，不可编译 |
| **API 雏形** | 中 | `void* Alloc(size_t size, size_t alignment);` | 接近真实代码的**简化声明**：函数名、参数类型、返回值；下游可据此写"桩调用" |
| **真实 API（头文件）** | 高 | 带 namespace、模板、错误处理、文档注释的完整声明 | **可编译**、正式交付 |

#### 4.5.2 各阶段职责与产物

| 阶段 | 产物 | 写在哪里 | 谁负责 | 何时 |
|------|------|----------|--------|------|
| **设计** | 能力列表 + 可选**伪代码** | 契约的「能力列表」小节或独立「伪代码」小节 | 模块负责人（人工或 Agent） | 模块实现**之前**；可在 /speckit.plan 或讨论中完成 |
| **细化** | **API 雏形**（简化声明） | 契约中增加「API 雏形」小节 | 同上 | 模块实现**开始前**或第一轮迭代完成后 |
| **实现** | **真实头文件** | 模块代码（如 `include/`） | 实现方 Agent / 人工 | 模块实现**进行中** |
| **交付/维护** | 契约「API 雏形」与真实 API 保持同步 | 契约 + 代码 | 实现方 | 每次对外 API 变更时同步更新契约 |

#### 4.5.3 下游模块基于什么？

| 上游状态 | 下游应基于 | 说明 |
|----------|-----------|------|
| 上游**尚未开始实现** | 契约中的 **API 雏形**（若无则看伪代码理解意图） | 下游可先写"桩调用"或 mock；接受后续小幅签名调整 |
| 上游**已实现** | 上游的**真实头文件**（与 API 雏形一致） | 直接 include 或按真实签名调用 |

**总结**：下游优先看 **API 雏形**（更接近可编译签名），伪代码主要用于快速理解意图。

#### 4.5.4 演进责任：谁、何时转换

| 转换 | 谁负责 | 何时 |
|------|--------|------|
| 能力列表 → **伪代码** | 模块负责人（设计阶段） | 讨论/plan 时，可选 |
| 伪代码 → **API 雏形** | 模块负责人 | 模块实现开始前完成；写进契约 |
| API 雏形 → **真实 API** | 实现方 | 模块实现进行中；真实头文件提交到模块分支 |
| 真实 API 变更 → **更新契约 API 雏形** | 实现方 | 每次对外 API 变更时同步到 T0-contracts |

#### 4.5.5 演进流程图

```
设计阶段         细化阶段               实现阶段                   交付/维护
   │                │                      │                          │
   ▼                ▼                      ▼                          ▼
能力列表 ──▶ (可选) 伪代码 ──▶ API 雏形（契约） ──▶ 真实 API（头文件） ──▶ 同步更新契约
                              ▲                          │
                              │                          │
                              └────────── 若真实 API 变更 ◀┘
```

**建议**：**L0 / L1 根模块**（001-Core、002-Object、003-Application、008-RHI 等）**契约先行**——在实现前把 API 雏形写进契约，再实现；下游实现时只依赖这些已定的接口。其他模块可按依赖顺序逐步补充契约中的 API 雏形。

#### 4.5.6 开发流程如何继续（契约尚无 API 雏形时）

当契约中**只有能力列表、尚无 API 雏形**（甚至没有伪代码）时，按以下方式确定接口并继续开发：

| 情况 | 谁来做 | 何时 | 怎么做 |
|------|--------|------|--------|
| **本模块（上游）** 契约尚无 API 雏形 | 本模块负责人（或执行 plan 的 Agent） | 在 **/speckit.plan** 阶段 | plan 结束时产出一份「契约更新」：把对外函数签名与类型写成可粘贴到契约「API 雏形」小节的格式；按 §4.2 写回 T0-contracts 上本模块契约，再继续 tasks/implement。 |
| **上游** 契约尚无 API 雏形，本模块是下游 | 下游实现方 | 下游 plan / 实现前 | 先看上游契约的**能力列表**（及若有**伪代码**）理解意图；在 plan 中按“假设的”签名写调用（或写桩/mock），并注明「依上游契约能力列表，具体签名以对方 API 雏形为准」；待上游补全 API 雏形后，按 §4.6 拉取契约并做一次适配。 |

**结论**：接口的确定不要求“契约一开始就有完整 API 雏形”。**上游**在 plan 阶段即可产出并写回 API 雏形；**下游**可先基于能力列表（及伪代码）开发，接受上游补全 API 雏形后的小幅适配。L0/L1 仍建议**契约先行**，优先把 API 雏形写进契约再实现，以减少下游返工。

### 4.6 Agent 何时、如何发现依赖接口变化

| 时机 | 操作 | 说明 |
|------|------|------|
| **开始工作前** | `git pull origin T0-contracts`，阅读本模块依赖的契约及**变更记录** | 确保本地契约最新；若有变更，根据变更记录判断是否影响本模块。 |
| **每个 task / 每次会话开始前** | 再次 `git pull origin T0-contracts`（可选但推荐） | 若任务执行较长时间，上游可能已更新契约；任务开始前拉取可减少“做到一半才发现接口变了”的情况。 |
| **看到规约中的待办时** | 先拉 T0-contracts，再打开该契约的**变更记录**，做适配 | 本模块规约 `docs/module-specs/NNN-modulename.md` 中若有「需随 XXX 契约变更做适配」的待办，执行前**必须先**拉取最新契约，阅读该契约的变更说明，再根据待办与变更记录自行判断适配时间与修改内容。 |

**总结**：Agent **不会自动**发现“拉取之后”发生的契约变更；依赖**拉取时机**（工作前、任务前）与 **规约中的待办**来获知变化。因此务必**按任务粒度或会话开始时拉取 T0-contracts**，并**定期查看本模块规约**；若规约中有上游契约变更的待办，**先拉再适配**。

---

## 5. 契约文件怎么写

- **文件名**：统一为 `NNN-modulename-public-api.md`（如 `001-core-public-api.md`、`008-rhi-public-api.md`）；边界契约为 `pipeline-to-rci.md`。
- **建议结构**（可随需要增删）：
  - **适用模块**：本契约由哪一模块（如 001-Core）实现并负责。
  - **消费者**：哪些模块依赖本契约（与 `000-module-dependency-map.md` 一致）。
  - **版本/ABI**：当前契约对应的版本或 ABI 承诺。
  - **类型与句柄**：跨边界使用的关键类型、句柄、枚举（名称、语义、生命周期）。
  - **接口/能力列表**：提供方保证提供的能力；用自然语言或**伪代码**简述意图（如 `Allocator.Alloc(size, alignment) → ptr or null`）。
  - **API 雏形**（可选但推荐）：用接近真实代码的**简化声明**描述关键 API（如 `void* Alloc(size_t size, size_t alignment);`）；下游可据此写桩调用。不要求一开始写全，可随实现迭代补充。真实 API 变更时需同步更新此小节。
  - **调用顺序与约束**：如“必须先初始化再创建资源”“命令缓冲在帧末提交”。
  - **变更记录**：重要变更的日期与简要说明。

契约以**稳定、可被多 Agent 引用**为目标，避免实现细节；实现细节留在各模块的规格或代码中。

---

## 6. 在规格中引用契约

在各模块的 `docs/module-specs/NNN-modulename.md` 或对应 spec 中建议包含：

- **本模块提供/实现的契约**：例如“本模块实现契约 `specs/_contracts/001-core-public-api.md`”。
- **本模块依赖的契约**：在 **Dependencies** 或 **模块上下游** 中列出，例如“依赖 `specs/_contracts/001-core-public-api.md`、`specs/_contracts/008-rhi-public-api.md`”。

这样，任何 Agent 打开该规格时都能直接跳转到契约文件，保证实现与接口定义一致。

---

## 7. 小结

- **主分支（master/main）仅用于配置**，不作为契约来源；**契约必须从 T0-contracts 拉取**，不得以主分支上的 `_contracts/` 为依据。
- **T0-contracts** 是 T0 架构下契约的**唯一权威发布源**；各 **T0-NNN-modulename** 分支工作前**必须**从此分支拉取最新契约（`git pull origin T0-contracts`）。
- 接口的**单一事实来源**在 `specs/_contracts/`（**仅以 T0-contracts 分支上的内容为准**）。
- 每个 Agent：**工作前**从 **T0-contracts** 拉取契约，**读**自己依赖的契约，**写/改**自己负责的契约（在 **T0-contracts** 上更新），**改接口时**更新契约并通知下游。
- **接口如何确定**：**伪代码**（意图）→ **API 雏形**（简化声明）→ **真实 API**（头文件）；详见 **4.5**。L0/L1 建议**契约先行**：实现前把 API 雏形写进契约，实现严格按契约，下游基于 API 雏形或真实头文件。**契约尚无 API 雏形时如何继续**：上游在 plan 阶段产出并写回 API 雏形；下游可先依能力列表/伪代码开发，待上游补全后再适配；详见 **4.5.6**。
- **Agent 何时发现依赖接口变化**：工作前、**每个 task 开始前**拉取 T0-contracts；看到本模块规约中的待办时先拉再适配。详见 **4.6**。
- 依赖图 `000-module-dependency-map.md` 与 `docs/dependency-graph-full.md` 用于快速查“谁依赖谁”和“改了这个会影响谁”。

**旧版说明**：原 `contracts` 分支与 001–006 旧 spec 对应；现以 **T0-contracts** 与 **T0-001-core … T0-027-xr** 为最新架构，旧分支与旧 spec 已弃用。
