# Feature Specification: Shader 系统（Shader System）

**Feature Branch**: `005-shader-system`  
**Created**: 2025-01-28  
**Status**: Draft  
**Input**: User description: "Shader系统：支持各种shader语法转换、Shader编译、预编译、Shader变体、Shader离线编译。Shader读取。可以作为动态链接库、源码、exe工具。"

## Clarifications

### Session 2025-01-28

- Q: 预编译产物加载的延迟目标或单次 shader 编译的耗时目标？ → A: 仅定性“尽量快”，不做定量目标；具体指标在实现阶段定义。

## User Scenarios & Testing *(mandatory)*

### User Story 1 - Shader 读取与基础编译 (Priority: P1)

用户（或上层系统）能够将 shader 源码提供给 Shader 系统，系统完成读取并产出可被渲染管线使用的 shader 表示。用户可请求对 shader 进行编译，编译成功后得到可在运行时使用的 shader 程序。

**Why this priority**: 读取与编译是 Shader 系统的基础能力；没有这两项，语法转换、变体、预编译等无从谈起。

**Independent Test**: 向系统提供一份 shader 源码（文件或内存），执行读取与编译，验证能够成功得到可被渲染接口使用的 shader 程序，并可完成一次简单的绘制验证。

**Acceptance Scenarios**:

1. **Given** 系统已配置对某一种 shader 语法或格式的支持，**When** 用户提供该格式的 shader 源码并请求读取，**Then** 系统完成读取并返回可引用的 shader 表示（或句柄），且该 shader 可被查询与后续编译。
2. **Given** shader 已成功读取，**When** 用户请求编译该 shader，**Then** 系统完成编译并返回可被渲染管线使用的 shader 程序；若编译失败，则返回明确的错误信息。
3. **Given** 用户通过文件路径或资源标识提供 shader，**When** 请求读取，**Then** 系统能够从指定来源加载 shader 内容并完成解析与登记。

---

### User Story 2 - 多种 Shader 语法转换 (Priority: P1)

用户提供的 shader 可能来自不同工具链或使用不同语法（如 HLSL、GLSL、MSL 等）。系统能够将这些语法转换为目标格式或统一中间表示，以便后续编译与使用，支撑跨平台与跨工具链工作流。

**Why this priority**: 语法转换使引擎能够接纳多种来源的 shader，是跨平台与工具链集成的前提。

**Independent Test**: 提供至少两种不同语法的 shader 源码，请求转换（或转换后编译），验证系统能正确转换并产出可用的 shader 程序。

**Acceptance Scenarios**:

1. **Given** 系统支持语法 A 与语法 B，**When** 用户提供语法 A 的 shader 并请求转换为目标格式，**Then** 系统完成转换并产出目标格式的表示，且该表示可被编译或直接使用。
2. **Given** 用户提供语法 B 的 shader，**When** 请求转换为与当前渲染后端兼容的格式，**Then** 转换结果与后端兼容，编译通过后可正常参与渲染。
3. **Given** 用户提供的语法不在支持范围内或无法识别，**When** 请求转换，**Then** 系统返回明确的错误或不受支持的信息，且不破坏其他 shader 的处理。

---

### User Story 3 - 预编译与离线编译 (Priority: P2)

用户能够在编辑时或构建流水线中对 shader 进行预编译或离线编译，将编译产物持久化。运行时可直接加载预编译产物，减少编译开销、加快加载速度。

**Why this priority**: 预编译与离线编译对加载性能与迭代效率影响大，是生产环境常用能力。

**Independent Test**: 对指定 shader 执行预编译或离线编译，将产物保存；在运行时加载该产物，验证可直接使用且行为与即时编译一致（在相同配置下）。

**Acceptance Scenarios**:

1. **Given** shader 已读取且可编译，**When** 用户请求预编译（或离线编译），**Then** 系统产出预编译产物并可选择持久化到指定位置。
2. **Given** 预编译产物已存在，**When** 用户请求加载该产物，**Then** 系统直接使用产物构造可用的 shader 程序，无需再次编译源码。
3. **Given** 预编译产物与当前运行时环境不兼容（如目标图形 API 或版本不同），**When** 用户请求加载，**Then** 系统返回明确错误，并可选地回退到即时编译（若源码可用）。

---

### User Story 4 - Shader 变体 (Priority: P2)

用户能够基于同一 shader 定义多个变体（如通过宏、质量档位、特性开关等）。系统支持变体的生成、筛选、存储与加载，满足不同功能与性能配置的需求。

**Why this priority**: 变体能力支撑材质与渲染的灵活配置，是现代渲染管线的常见需求。

**Independent Test**: 为同一 shader 定义至少两个变体，生成并存储变体；请求加载特定变体，验证系统能正确解析变体标识、定位并加载对应变体，且渲染结果符合预期。

**Acceptance Scenarios**:

1. **Given** 用户已定义变体规则（如宏定义集合），**When** 请求生成变体，**Then** 系统根据规则生成对应变体表示，并可为每个变体分配唯一标识。
2. **Given** 变体已生成，**When** 用户通过变体标识请求加载，**Then** 系统加载并返回正确的变体 shader，且不影响其他变体。
3. **Given** 用户请求不存在的变体标识，**When** 系统无法找到对应变体，**Then** 返回明确错误；若配置了回退策略，则按策略返回默认变体或错误。

---

### User Story 5 - 多种分发与集成形态 (Priority: P3)

Shader 系统能够以多种形态交付与集成：作为动态链接库（DLL）被主工程或工具调用、以源码形式与引擎一起编译、或作为独立可执行工具（exe）在构建流水线或离线场景中使用。集成方可根据部署与协作需求选择合适形态。

**Why this priority**: 灵活的分发形态满足引擎内嵌、插件化、CI/CD 与离线工具等不同集成场景。

**Independent Test**: 以至少两种形态（如 DLL 与 exe）集成 Shader 系统，分别执行读取、编译（或预编译）与产物使用（或输出），验证行为一致且接口可用。

**Acceptance Scenarios**:

1. **Given** Shader 系统以动态链接库形式提供，**When** 主工程或工具加载该库并调用约定接口，**Then** 能够完成 shader 读取、编译（或预编译）及产物查询等核心操作。
2. **Given** Shader 系统以源码形式提供，**When** 集成方将源码编译进引擎或工具，**Then** 能够通过相同逻辑接口完成上述核心操作，与库形态行为一致。
3. **Given** Shader 系统以独立可执行工具形式提供，**When** 用户通过命令行或脚本调用该工具并传入 shader 路径与参数，**Then** 工具能够执行编译、预编译或变体生成等操作，并输出约定格式的产物或结果信息。

---

### Edge Cases

- 当 shader 源码格式无法识别或转换失败时，系统应返回明确的错误信息，且不破坏其他 shader 的处理状态。
- 当编译失败（如语法错误、目标不支持）时，系统应提供可定位的错误信息（如行号、片段），且支持继续处理其他 shader。
- 当预编译产物损坏、版本不匹配或与当前运行时环境不兼容时，系统应检测并报告错误，并可配置为回退到即时编译或拒绝加载。
- 当变体数量或组合过多导致存储或枚举性能问题时，系统应支持按需生成、惰性加载或分块管理，以缓解延迟与内存占用；“可接受”的具体尺度由实现定义。
- 当以 exe 工具形态运行时，若输入路径无效、参数错误或输出目录不可写，工具应返回明确的错误码或日志，便于流水线诊断。
- 当多线程同时请求编译、预编译或变体生成时，系统应保证线程安全，避免竞态与未定义行为。

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: 系统必须支持从至少一种来源（如文件路径、资源标识或内存）读取 shader 源码，并生成系统内可引用的 shader 表示。
- **FR-002**: 系统必须支持对已读取的 shader 进行编译，产出可被渲染管线使用的 shader 程序；编译失败时必须提供明确的错误信息。
- **FR-003**: 系统必须支持至少两种不同 shader 语法或格式的转换，将源码转换为目标格式或统一中间表示，以支撑后续编译。
- **FR-004**: 系统在无法识别或无法转换某语法时，必须返回明确错误，且不影响其他 shader 的处理。
- **FR-005**: 系统必须支持 shader 的预编译或离线编译，并支持将编译产物持久化与后续加载；加载预编译产物时无需再次编译源码。
- **FR-006**: 系统在加载预编译产物时，若产物不兼容或损坏，必须检测并报告错误；可配置为回退到即时编译（当源码可用时）。
- **FR-007**: 系统必须支持基于同一 shader 的变体（如宏、配置等），包括变体生成、标识解析、按标识加载，以及可选的默认变体或回退策略。
- **FR-008**: 系统必须支持以动态链接库形式集成，通过约定接口提供读取、编译、预编译、变体等相关能力。
- **FR-009**: 系统必须支持以源码形式集成，与库形态在核心能力上保持一致，可通过相同逻辑接口使用。
- **FR-010**: 系统必须支持以独立可执行工具形式集成，通过命令行或脚本驱动，完成编译、预编译或变体生成等操作并输出约定产物或结果。
- **FR-011**: 系统在并发调用编译、预编译或变体生成时，必须保证线程安全，行为可预测、无未定义结果。
- **FR-012**: 系统必须提供明确的错误与诊断信息（如编译失败原因、 incompatible 预编译产物、无效变体标识等），便于集成方与流水线排查问题。

### Key Entities

- **Shader 源码（Shader Source）**: 用户提供的 shader 文本或二进制表示；具备格式或语法类型、来源标识；可被读取、转换与编译。
- **Shader 程序（Shader Program）**: 编译或加载后的可执行表示；可被渲染管线使用；与目标图形 API 或后端相关。
- **预编译产物（Precompiled Artifact）**: 预编译或离线编译得到的持久化结果；可被加载以跳过即时编译；具备格式与兼容性约束。
- **Shader 变体（Shader Variant）**: 基于同一 shader 的特定配置实例；具备唯一标识；可独立生成、存储与加载。
- **语法/格式类型（Syntax / Format Type）**: 对 shader 源码形式的分类（如 HLSL、GLSL、MSL 等）；决定转换与编译的具体语义。

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: 用户能够从至少一种来源成功读取 shader 源码，完成编译，并得到可在渲染管线中使用的 shader 程序；且能通过一次简单绘制验证其可用性。
- **SC-002**: 用户提供至少两种不同语法的 shader 时，系统能正确转换并编译，且两种均能参与渲染，行为符合各自语义。
- **SC-003**: 用户对指定 shader 执行预编译并持久化后，在运行时加载该预编译产物可直接使用，无需再次编译；在相同配置下，渲染结果与即时编译一致。
- **SC-004**: 用户为同一 shader 定义至少两个变体并生成后，能通过变体标识正确加载对应变体，且变体间互不干扰。
- **SC-005**: Shader 系统以动态链接库与以独立可执行工具两种形态集成时，均能完成读取、编译（或预编译）及产物输出等核心操作，行为一致。
- **SC-006**: 在编译失败、转换失败、预编译产物不兼容或变体不存在等情况下，用户或集成方能获得明确的错误或诊断信息，且其他 shader 或变体的处理不受影响。
- **SC-007**: 多线程并发调用编译、预编译或变体加载时，系统无崩溃、无未定义行为，且结果可正确复现。

## Assumptions

- 性能与规模目标（如预编译产物加载延迟、单次 shader 编译耗时）仅作定性要求（“尽量快”）；具体数值与可测量指标在实现阶段定义。
- “各种 shader 语法”指至少支持两种常见语法（如 HLSL、GLSL 等）；具体集合与转换规则由实现阶段决定，本规格不绑定具体语法名称或版本。
- 预编译与离线编译的存储格式、目录布局及与运行时环境的兼容性规则由实现定义；本规格仅要求能力存在且加载时行为明确。
- 变体的定义方式（如宏、配置文件、质量档位等）与命名规则由实现定义；本规格仅要求变体可生成、可标识、可加载。
- 动态链接库、源码与可执行工具的接口形态与调用约定由实现定义；本规格仅要求三种形态均能提供核心能力且行为一致。
- 渲染管线与图形 API 的对接由 RCI 或渲染模块负责；本规格关注 shader 的读取、转换、编译、预编译、变体及分发形态，不涉及具体渲染调用。
- 资源系统若负责 shader 文件的导入与加载，则与 Shader 系统的“读取”为协作关系；本规格不假定必须依赖资源系统，仅假定 shader 内容可按需获取。

## Dependencies

- 需要与渲染模块（如 RCI 接口）配合，将编译后的 shader 程序提交给渲染管线使用。
- 可能依赖平台抽象与文件 I/O（如来自 Core 模块），用于 shader 文件读取与预编译产物持久化。
- 以动态链接库或可执行工具形态分发时，依赖目标环境的加载与执行能力（如 DLL 加载、命令行执行）。
